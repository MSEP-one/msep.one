class_name CollisionEngine extends Node
## Responsible for fetching collision information

# PhysicEngine is not prepared for working on such small scale,
# this const is used to rescale the physic space to something more suitable
const PHYSIC_SPACE_SIZE_FACTOR: float = 20.0

const _BOND_COLLISION_DATA_TRANSFORM: int = 0
const _BOND_COLLISION_DATA_SHAPE_HALF_SIZE: int = 1
const VIRTUAL_OBJECT_ID: int = 1

enum CollisionLayer {
	DEFAULT        = 1 << 0,
	HYDROGEN       = 1 << 1,
	VIRTUAL_OBJECT = 1 << 2,
}

var _structure_context: StructureContext
var _atom_collision_space: CollisionSpace
var _bond_collision_space: CollisionSpace
var _spring_collision_space: CollisionSpace
var _disabled: bool = false
var _last_scan_size: int = 100
var _need_to_recreate_on_tree_enter: bool = false
var _atomic_nmb_to_collision_shape: Dictionary = {
	# element_type<int> : shape_rid<RID> (RID generated by PhysicsServer3D)
}
var _atomic_nmb_to_radius: Dictionary = {
	# atomic_number<int>: radius<float>
}
var _bond_order_and_atom_radius_to_bond_radius: Dictionary = {
	# bond_order_and_atom_radius<Vector2> : bond_radius<float>
}
var _motor_shape_rid: RID # = PhysicsServer3D.sphere_shape_create()
var _anchor_shape_rid: RID # = PhysicsServer3D.sphere_shape_create()
var _spring_shape_rid: RID # = PhysicsServer3D.box_shape_create()
var _hydrogens_enabled: bool = true
var _is_initialized: bool = false


func _notification(in_what: int) -> void:
	if in_what == NOTIFICATION_SCENE_INSTANTIATED:
		_atom_collision_space = get_node("AtomCollisionSpace") as CollisionSpace
		_bond_collision_space = get_node("BondCollisionSpace") as CollisionSpace
		_spring_collision_space = get_node("SpringCollisionSpace") as CollisionSpace
	
	if in_what == NOTIFICATION_EXIT_TREE:
		# free the memory while CollisionSpace objects are still available
		_clear_physic_space()
		_need_to_recreate_on_tree_enter = true
	
	if in_what == NOTIFICATION_ENTER_TREE:
		if _need_to_recreate_on_tree_enter:
			assert(is_instance_valid(_structure_context.nano_structure))
			_need_to_recreate_on_tree_enter = false
			initialize(_structure_context)


func initialize(in_structure_context: StructureContext) -> void:
	_structure_context = in_structure_context
	var nano_structure: NanoStructure = in_structure_context.nano_structure
	var representation_settings: RepresentationSettings = nano_structure.get_representation_settings()
	_hydrogens_enabled = representation_settings.get_hydrogens_visible()
	_refresh_atom_radiuses()
	_refresh_bond_radiuses()
	_initialize_atom_shapes()
	_initialize_virtual_objects_shape()
	
	if not representation_settings.representation_changed.is_connected(_on_representation_settings_representation_changed):
		representation_settings.representation_changed.connect(_on_representation_settings_representation_changed)
	if not representation_settings.balls_and_sticks_size_factor_changed.is_connected(_on_representation_settings_balls_and_sticks_size_factor_changed):
		representation_settings.balls_and_sticks_size_factor_changed.connect(_on_representation_settings_balls_and_sticks_size_factor_changed)
	if not representation_settings.balls_and_sticks_size_source_changed.is_connected(_on_representation_settings_balls_and_sticks_size_source_changed):
		representation_settings.balls_and_sticks_size_source_changed.connect(_on_representation_settings_balls_and_sticks_size_source_changed)
	if not representation_settings.hydrogen_visibility_changed.is_connected(_on_representation_settings_hydrogen_visibility_changed):
		representation_settings.hydrogen_visibility_changed.connect(_on_representation_settings_hydrogen_visibility_changed)
	if not nano_structure.visibility_changed.is_connected(_on_nano_structure_visibility_changed):
		nano_structure.visibility_changed.connect(_on_nano_structure_visibility_changed)
	if nano_structure is AtomicStructure:
		if not nano_structure.atoms_added.is_connected(_on_nano_structure_atoms_added):
			nano_structure.atoms_added.connect(_on_nano_structure_atoms_added)
		if not nano_structure.atoms_removed.is_connected(_on_nano_structure_atoms_removed):
			nano_structure.atoms_removed.connect(_on_nano_structure_atoms_removed)
		if not nano_structure.atoms_moved.is_connected(_on_nano_structure_atoms_moved):
			nano_structure.atoms_moved.connect(_on_nano_structure_atoms_moved)
		if not nano_structure.atoms_atomic_number_changed.is_connected(_on_nano_structure_atoms_atomic_number_changed):
			nano_structure.atoms_atomic_number_changed.connect(_on_nano_structure_atoms_atomic_number_changed)
		if not nano_structure.atoms_visibility_changed.is_connected(_on_nano_structure_atoms_visibility_changed):
			nano_structure.atoms_visibility_changed.connect(_on_nano_structure_atoms_visibility_changed)
		if not nano_structure.atoms_cleared.is_connected(_on_nano_structure_atoms_cleared):
			nano_structure.atoms_cleared.connect(_on_nano_structure_atoms_cleared)
		if not nano_structure.bonds_created.is_connected(_on_nano_structure_bonds_created):
			nano_structure.bonds_created.connect(_on_nano_structure_bonds_created)
		if not nano_structure.bonds_removed.is_connected(_on_nano_structure_bonds_removed):
			nano_structure.bonds_removed.connect(_on_nano_structure_bonds_removed)
		if not nano_structure.bonds_changed.is_connected(_on_nano_structure_bonds_changed):
			nano_structure.bonds_changed.connect(_on_nano_structure_bonds_changed)
		if not nano_structure.bonds_visibility_changed.is_connected(_on_nano_structure_bonds_visibility_changed):
			nano_structure.bonds_visibility_changed.connect(_on_nano_structure_bonds_visibility_changed)
		if not nano_structure.springs_added.is_connected(_on_nano_structure_springs_added):
			nano_structure.springs_added.connect(_on_nano_structure_springs_added)
		if not nano_structure.springs_removed.is_connected(_on_nano_structure_springs_removed):
			nano_structure.springs_removed.connect(_on_nano_structure_springs_removed)
		if not nano_structure.springs_moved.is_connected(_on_nano_structure_springs_moved):
			nano_structure.springs_moved.connect(_on_nano_structure_springs_moved)
		if not nano_structure.springs_visibility_changed.is_connected(_on_nano_structure_springs_visibility_changed):
			nano_structure.springs_visibility_changed.connect(_on_nano_structure_springs_visibility_changed)

		
		var valid_atoms: PackedInt32Array = nano_structure.get_valid_atoms()
		for atom_id in valid_atoms:
			_add_atom(atom_id, nano_structure)
		
		var valid_bonds: PackedInt32Array = nano_structure.get_valid_bonds()
		for bond_id in valid_bonds:
			_add_bond(bond_id, nano_structure)
		
		var springs: PackedInt32Array = nano_structure.springs_get_valid()
		for spring_id in springs:
			_add_spring(spring_id)
	
	if nano_structure is NanoVirtualMotor:
		_add_motor(nano_structure as NanoVirtualMotor)
	
	if nano_structure is NanoVirtualAnchor:
		_add_anchor(nano_structure as NanoVirtualAnchor)
	
	_is_initialized = true


func is_initialized() -> bool:
	return _is_initialized


func _refresh_atom_radiuses() -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	var rep_settings: RepresentationSettings = nano_structure.get_representation_settings()
	for atomic_nmb in range(1, PeriodicTable.MAX_ATOMIC_NUMBER + 1):
		_atomic_nmb_to_radius[atomic_nmb] = RenderingUtils.calculate_atom_visual_radius(
				atomic_nmb, rep_settings) * PHYSIC_SPACE_SIZE_FACTOR


func _refresh_bond_radiuses() -> void:
	assert(not _atomic_nmb_to_radius.is_empty())
	var nano_structure: NanoStructure = _structure_context.nano_structure
	var rep_settings: RepresentationSettings = nano_structure.get_representation_settings()
	for bond_order: int in [1, 2, 3]:
		for atomic_nmb: int in _atomic_nmb_to_radius.keys():
			var atom_radius: float = _atomic_nmb_to_radius[atomic_nmb]
			var bond_radius: float = -1.0
			match rep_settings.get_rendering_representation():
				# Capsule rendering:
				Rendering.Representation.STICKS, \
				Rendering.Representation.ENHANCED_STICKS, \
				Rendering.Representation.ENHANCED_STICKS_AND_BALLS:
					bond_radius = CapsuleStickRepresentation.calc_bond_visual_radius(bond_order, atom_radius)
				# Cylinder rendering:
				_:
					bond_radius = CylinderStickRepresentation.calc_bond_visual_radius(bond_order, atom_radius)
			var bond_order_and_atom_radius: Vector2 = Vector2(bond_order, atom_radius)
			_bond_order_and_atom_radius_to_bond_radius[bond_order_and_atom_radius] = bond_radius


func _initialize_atom_shapes() -> void:
	for atomic_nmb in range(1, PeriodicTable.MAX_ATOMIC_NUMBER + 1):
		var shape_rid: RID = PhysicsServer3D.sphere_shape_create()
		var radius: float = _atomic_nmb_to_radius[atomic_nmb]
		PhysicsServer3D.shape_set_data(shape_rid, radius)
		_atomic_nmb_to_collision_shape[atomic_nmb] = shape_rid


func _initialize_virtual_objects_shape() -> void:
	const MOTOR_COLLISION_RADIUS: float = 2.5
	const SPRING_BOX_EXTENTS: Vector3 = Vector3.ONE * 0.5
	_motor_shape_rid = PhysicsServer3D.sphere_shape_create()
	PhysicsServer3D.shape_set_data(_motor_shape_rid, MOTOR_COLLISION_RADIUS)
	_anchor_shape_rid = PhysicsServer3D.sphere_shape_create()
	PhysicsServer3D.shape_set_data(_anchor_shape_rid, NanoVirtualAnchor.MODEL_SIZE * 0.5 * PHYSIC_SPACE_SIZE_FACTOR)
	_spring_shape_rid = PhysicsServer3D.box_shape_create()
	PhysicsServer3D.shape_set_data(_spring_shape_rid, SPRING_BOX_EXTENTS)
	


func _on_representation_settings_representation_changed(_new_representation: Rendering.Representation) -> void:
	_refresh_atom_radiuses()
	_refresh_bond_radiuses()
	_update_atom_shapes()
	_update_bond_shapes()


func _on_representation_settings_balls_and_sticks_size_factor_changed(_new_factor: float) -> void:
	_refresh_atom_radiuses()
	_refresh_bond_radiuses()
	_update_atom_shapes()
	_update_bond_shapes()


func _on_representation_settings_balls_and_sticks_size_source_changed(_new_source: RepresentationSettings.UserAtomSizeSource) -> void:
	_refresh_atom_radiuses()
	_refresh_bond_radiuses()
	_update_atom_shapes()
	_update_bond_shapes()


func _on_representation_settings_hydrogen_visibility_changed(in_hydrogens_visible: bool) -> void:
	_hydrogens_enabled = in_hydrogens_visible


func _on_nano_structure_visibility_changed(in_visible: bool) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	# Nano shapes collision detection is detected differently
	if nano_structure.is_virtual_object() and not nano_structure is NanoShape:
		_atom_collision_space.set_collider_enabled(VIRTUAL_OBJECT_ID, in_visible)


func _on_nano_structure_atoms_visibility_changed(in_atoms: PackedInt32Array) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for atom_id: int in in_atoms:
		if not _atom_collision_space.is_external_id_known(atom_id):
			continue
		var is_visible: bool = not nano_structure.is_atom_hidden_by_user(atom_id)
		_atom_collision_space.set_collider_enabled(atom_id, is_visible)


func _on_nano_structure_bonds_visibility_changed(in_bonds: PackedInt32Array) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for bond_id: int in in_bonds:
		if not _bond_collision_space.is_external_id_known(bond_id):
			continue
		var is_visible: bool = not nano_structure.is_bond_hidden_by_user(bond_id)
		_bond_collision_space.set_collider_enabled(bond_id, is_visible)


func _update_atom_shapes() -> void:
	for atomic_nmb in range(1, PeriodicTable.MAX_ATOMIC_NUMBER + 1):
		var shape_rid: RID = _atomic_nmb_to_collision_shape[atomic_nmb]
		PhysicsServer3D.shape_set_data(shape_rid, _atomic_nmb_to_radius[atomic_nmb])


func _update_bond_shapes() -> void:
	var bonds: PackedInt32Array = _bond_collision_space.get_all_ids()
	_update_transforms_for_bonds(bonds)


func _on_nano_structure_atoms_added(in_atoms_added: PackedInt32Array) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for atom_id in in_atoms_added:
		_add_atom(atom_id, nano_structure)


func _on_nano_structure_atoms_removed(in_atoms_removed: PackedInt32Array) -> void:
	for atom_id in in_atoms_removed:
		_atom_collision_space.free_collider_and_get_related_shape(atom_id)


func _on_nano_structure_atoms_moved(in_atoms_moved: PackedInt32Array) -> void:
	var nano_structure: AtomicStructure = _structure_context.nano_structure
	var bonds_to_update: Dictionary = {}
	for atom_id in in_atoms_moved:
		_update_atom_position(atom_id)
		var bonds: = nano_structure.atom_get_bonds(atom_id)
		for bond in bonds:
			bonds_to_update[bond] = true
	_update_transforms_for_bonds(PackedInt32Array(bonds_to_update.keys()))


func _on_nano_structure_atoms_atomic_number_changed(changed_atoms: Array[Vector2i]) -> void:
	var bonds_to_update: Dictionary = {}
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for atom_and_atomic_nmb_pair in changed_atoms:
		var atom_id: int = atom_and_atomic_nmb_pair.x
		var atomic_nmb: int = atom_and_atomic_nmb_pair.y
		var new_shape_rid: RID = _atomic_nmb_to_collision_shape[atomic_nmb]
		var is_hydrogen: bool = atomic_nmb == PeriodicTable.ATOMIC_NUMBER_HYDROGEN
		var collision_layer: int = CollisionLayer.HYDROGEN if is_hydrogen else CollisionLayer.DEFAULT
		_atom_collision_space.replace_shape_keep_old(atom_id, new_shape_rid)
		_atom_collision_space.change_collision_layer(atom_id, collision_layer)
		var bonds_ids: PackedInt32Array = nano_structure.atom_get_bonds(atom_id)
		for bond: int in bonds_ids:
			bonds_to_update[bond] = true
	
	var bonds_ids_to_update: PackedInt32Array = PackedInt32Array(bonds_to_update.keys())
	_update_layer_for_bonds(bonds_ids_to_update)
	_update_transforms_for_bonds(bonds_ids_to_update)


func _update_layer_for_bonds(in_bonds: PackedInt32Array) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for bond_id: int in in_bonds:
		var is_hydrogen_involved: bool = _is_hydrogen_involved_in_bond(bond_id, nano_structure)
		var bond_collision_layer: int = CollisionLayer.HYDROGEN if is_hydrogen_involved else CollisionLayer.DEFAULT
		_bond_collision_space.change_collision_layer(bond_id, bond_collision_layer)


func _on_nano_structure_atoms_cleared() -> void:
	# don't do anything with atom shapes, they are cached in _atomic_nmb_to_collision_shape
	_atom_collision_space.free_colliders_and_get_shapes()
	
	# bond_shapes_to_free: Array[RID]
	var bond_shapes_to_free: Array = _bond_collision_space.free_colliders_and_get_shapes()
	for shape_rid: RID in bond_shapes_to_free:
		PhysicsServer3D.free_rid(shape_rid)


func _on_nano_structure_bonds_created(new_bonds: PackedInt32Array) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for bond_id in new_bonds:
		_add_bond(bond_id, nano_structure)


func _on_nano_structure_bonds_removed(in_removed_bonds: PackedInt32Array) -> void:
	for bond_id in in_removed_bonds:
		var old_shape: RID = _bond_collision_space.free_collider_and_get_related_shape(bond_id)
		PhysicsServer3D.free_rid(old_shape)


func _update_atom_position(in_atom_id: int) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	var position: Vector3 = nano_structure.atom_get_position(in_atom_id) * PHYSIC_SPACE_SIZE_FACTOR
	_atom_collision_space.update_collider_transform(in_atom_id, Transform3D(Basis(), position))


func _on_nano_structure_bonds_changed(in_changed_bonds: PackedInt32Array) -> void:
	_update_transforms_for_bonds(in_changed_bonds)


func _update_transforms_for_bonds(in_bonds_to_update: PackedInt32Array) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for bond_id in in_bonds_to_update:
		_update_bond_transform(bond_id, nano_structure)


func _update_bond_transform(in_bond_id: int,  in_nano_structure: NanoStructure) -> void:
	var bond_data: Array = _calculate_bond_collision_data(in_bond_id, in_nano_structure)
	var shape_rid: RID = _bond_collision_space.get_shape_rid(in_bond_id)
	PhysicsServer3D.shape_set_data(shape_rid, bond_data[_BOND_COLLISION_DATA_SHAPE_HALF_SIZE])
	_bond_collision_space.update_collider_transform(in_bond_id, bond_data[_BOND_COLLISION_DATA_TRANSFORM])


func _calculate_bond_collision_data(in_bond_id: int, in_nano_structure: NanoStructure) -> Array:
	var result: Array = Array()
	result.resize(2)
	
	var bond: Vector3i = in_nano_structure.get_bond(in_bond_id)
	var first_atom_position: Vector3 = in_nano_structure.atom_get_position(bond.x) * PHYSIC_SPACE_SIZE_FACTOR
	var second_atom_position: Vector3 = in_nano_structure.atom_get_position(bond.y) * PHYSIC_SPACE_SIZE_FACTOR
	var first_atomic_nmb: int = in_nano_structure.atom_get_atomic_number(bond.x)
	var second_atomic_nmb: int = in_nano_structure.atom_get_atomic_number(bond.y)
	var first_radius: float = _atomic_nmb_to_radius[first_atomic_nmb]
	var second_radius: float = _atomic_nmb_to_radius[second_atomic_nmb]
	var bond_length: float = first_atom_position.distance_to(second_atom_position) - first_radius - second_radius
	var bond_height: float = _calculate_bond_radius(first_radius, second_radius, bond.z)
	var box_half_size: Vector3 = Vector3(bond_height, bond_height, bond_length) / 2.0
	result[_BOND_COLLISION_DATA_SHAPE_HALF_SIZE] = box_half_size
	
	var dir_from_first_to_second: Vector3 = first_atom_position.direction_to(second_atom_position)
	var first_atom_surface_point: Vector3 = first_atom_position + dir_from_first_to_second * first_radius
	var second_atom_surface_point: Vector3 =  second_atom_position - dir_from_first_to_second * second_radius
	var bond_position: Vector3 = (first_atom_surface_point + second_atom_surface_point) / 2.0
	var is_bond_perfectly_vertical: bool = is_equal_approx(abs(dir_from_first_to_second.dot(Vector3.UP)), 1.0)
	var right_dir := Vector3.RIGHT if is_bond_perfectly_vertical else dir_from_first_to_second.cross(Vector3.UP)
	var up_dir: Vector3 = right_dir.cross(dir_from_first_to_second)
	var bond_transform: Transform3D = Transform3D(Basis(), bond_position)
	if bond_transform.origin.distance_squared_to(first_atom_position) > 0.0001:
		bond_transform = bond_transform.looking_at(first_atom_position, up_dir)
	else:
		# Atoms are overlapping, make the bond collider tiny so it doesn't interfere with the
		# atoms colliders, but still allows box selecting the bond.
		bond_transform = bond_transform.scaled_local(Vector3.ONE * 0.001)
	result[_BOND_COLLISION_DATA_TRANSFORM] = bond_transform
	return result


func _calculate_bond_radius(in_first_atom_radius: float, in_second_atom_radius: float, in_bond_order: int) -> float:
	var smaller_atom_radius: float = min(in_first_atom_radius, in_second_atom_radius)
	var bond_order_and_atom_radius: Vector2 = Vector2(in_bond_order, smaller_atom_radius)
	return _bond_order_and_atom_radius_to_bond_radius[bond_order_and_atom_radius]


func _add_atom(in_atom_id: int, in_nano_structure: NanoStructure) -> void:
	var position: Vector3 = in_nano_structure.atom_get_position(in_atom_id)
	var atomic_nmb: int = in_nano_structure.atom_get_atomic_number(in_atom_id)
	var area_position: Vector3 = position * PHYSIC_SPACE_SIZE_FACTOR
	var transform: Transform3D = Transform3D(Basis(), area_position)
	var shape_rid: RID = _atomic_nmb_to_collision_shape[atomic_nmb]
	var is_hydrogen: bool = atomic_nmb == PeriodicTable.ATOMIC_NUMBER_HYDROGEN
	var collision_layer: int = CollisionLayer.HYDROGEN if is_hydrogen else CollisionLayer.DEFAULT
	_atom_collision_space.add_collider(in_atom_id, shape_rid, transform, collision_layer)
	if in_nano_structure.is_atom_hidden_by_user(in_atom_id):
		_atom_collision_space.set_collider_enabled(in_atom_id, false)


func _add_bond(in_bond_id: int, in_nano_structure: NanoStructure) -> void:
	var bond_data: Array = _calculate_bond_collision_data(in_bond_id, in_nano_structure)
	var shape_rid: RID = PhysicsServer3D.box_shape_create()
	var is_hydrogen_bond: bool = _is_hydrogen_involved_in_bond(in_bond_id, in_nano_structure)
	var collision_layer: int = CollisionLayer.HYDROGEN if is_hydrogen_bond else CollisionLayer.DEFAULT
	PhysicsServer3D.shape_set_data(shape_rid, bond_data[_BOND_COLLISION_DATA_SHAPE_HALF_SIZE])
	_bond_collision_space.add_collider(in_bond_id, shape_rid, bond_data[_BOND_COLLISION_DATA_TRANSFORM],
			collision_layer)
	if in_nano_structure.is_bond_hidden_by_user(in_bond_id):
		_bond_collision_space.set_collider_enabled(in_bond_id, false)


func _on_nano_structure_springs_added(in_springs_added: PackedInt32Array) -> void:
	for spring_id in in_springs_added:
		_add_spring(spring_id)


func _add_spring(in_spring: int) -> void:
	var atomic_structure: AtomicStructure = _structure_context.nano_structure as AtomicStructure
	var atom_id: int = atomic_structure.spring_get_atom_id(in_spring)
	var start: Vector3 = atomic_structure.atom_get_position(atom_id)
	var end: Vector3 = atomic_structure.spring_get_anchor_position(in_spring, _structure_context)
	var atomic_nmb: int = atomic_structure.atom_get_atomic_number(atom_id)
	var transform: Transform3D = _calculate_spring_transform(start, end, atomic_nmb)
	var is_hydrogen: bool = atomic_nmb == PeriodicTable.ATOMIC_NUMBER_HYDROGEN
	var collision_layer: int = CollisionLayer.HYDROGEN if is_hydrogen else CollisionLayer.DEFAULT
	_spring_collision_space.add_collider(in_spring, _spring_shape_rid, transform, collision_layer)
	if not atomic_structure.spring_is_visible(in_spring):
		_spring_collision_space.set_collider_enabled(in_spring, false)


func _on_nano_structure_springs_removed(in_springs_removed: PackedInt32Array) -> void:
	for spring_id in in_springs_removed:
		if not _spring_collision_space.is_external_id_known(spring_id):
			continue
		_spring_collision_space.free_collider_and_get_related_shape(spring_id)


func _on_nano_structure_springs_moved(in_springs_moved: PackedInt32Array) -> void:
	var nano_structure: NanoStructure = _structure_context.nano_structure
	for spring_id: int in in_springs_moved:
		if not _spring_collision_space.is_external_id_known(spring_id):
			continue
		var start: Vector3 = nano_structure.spring_get_atom_position(spring_id)
		var end: Vector3 = nano_structure.spring_get_anchor_position(spring_id, _structure_context)
		var atom_id: int = nano_structure.spring_get_atom_id(spring_id)
		var atomic_nmb: int = nano_structure.atom_get_atomic_number(atom_id)
		var transform: Transform3D = _calculate_spring_transform(start, end, atomic_nmb)
		_spring_collision_space.update_collider_transform(spring_id, transform)


func _on_nano_structure_springs_visibility_changed(in_springs: PackedInt32Array) -> void:
	if _structure_context.is_queued_for_deletion():
		# There's a corner case where this could happen:
		# When deleting a group in middle of a simulation the system will create a StructureContext
		# only during one frame to take a snapshot of the system with the simulation applyed,
		# but without the deletion. And then will delete it before the frame ends
		return
	var atomic_structure: AtomicStructure = _structure_context.nano_structure as AtomicStructure
	for spring_id: int in in_springs:
		if not _spring_collision_space.is_external_id_known(spring_id):
			continue
		var spring_visible: bool = atomic_structure.spring_is_visible(spring_id)
		_spring_collision_space.set_collider_enabled(spring_id, spring_visible)


func _is_hydrogen_involved_in_bond(in_bond_id: int, in_nano_structure: NanoStructure) -> bool:
	var bond: Vector3i = in_nano_structure.get_bond(in_bond_id)
	return in_nano_structure.atom_get_atomic_number(bond.x) == PeriodicTable.ATOMIC_NUMBER_HYDROGEN or \
			in_nano_structure.atom_get_atomic_number(bond.y) == PeriodicTable.ATOMIC_NUMBER_HYDROGEN


func _add_motor(in_motor: NanoVirtualMotor) -> void:
	var transform: Transform3D = _calculate_motor_transform(in_motor.get_transform())
	_atom_collision_space.add_collider(VIRTUAL_OBJECT_ID, _motor_shape_rid, transform, CollisionLayer.VIRTUAL_OBJECT)
	if not in_motor.transform_changed.is_connected(_on_motor_transform_changed):
		in_motor.transform_changed.connect(_on_motor_transform_changed)


func _on_motor_transform_changed(in_transform: Transform3D) -> void:
	_atom_collision_space.update_collider_transform(VIRTUAL_OBJECT_ID, _calculate_motor_transform(in_transform))


func _add_anchor(in_anchor: NanoVirtualAnchor) -> void:
	var transform: Transform3D = _calculate_anchor_transform(in_anchor.get_position())
	_atom_collision_space.add_collider(VIRTUAL_OBJECT_ID, _anchor_shape_rid, transform, CollisionLayer.VIRTUAL_OBJECT)
	if not in_anchor.position_changed.is_connected(_on_anchor_position_changed):
		in_anchor.position_changed.connect(_on_anchor_position_changed)


func _on_anchor_position_changed(in_position: Vector3) -> void:
	_atom_collision_space.update_collider_transform(VIRTUAL_OBJECT_ID, _calculate_anchor_transform(in_position))


func _on_spring_is_visible_in_viewport_changed(in_visible: bool) -> void:
	_atom_collision_space.set_collider_enabled(VIRTUAL_OBJECT_ID, in_visible)


func _calculate_motor_transform(in_motor_transform: Transform3D) -> Transform3D:
	# This method provides an offset for the 3D model that matches the one of the renderer
	# returned transform is already multiplied by PHYSIC_SPACE_SIZE_FACTOR
	var new_transform: = in_motor_transform
	const MODEL_OFFSET: Vector3 = Vector3(-0.127, 0.025, 0)
	var model_offset: Vector3 = in_motor_transform.basis * MODEL_OFFSET
	new_transform.origin += model_offset
	new_transform.origin *= PHYSIC_SPACE_SIZE_FACTOR
	return new_transform


func _calculate_anchor_transform(in_anchor_position: Vector3) -> Transform3D:
	# returned transform is already multiplied by PHYSIC_SPACE_SIZE_FACTOR
	var new_transform := Transform3D(Basis(), in_anchor_position)
	new_transform.origin *= PHYSIC_SPACE_SIZE_FACTOR
	return new_transform


func _calculate_spring_transform(in_atom_position: Vector3, in_anchor_position: Vector3,
			in_atomic_nmb: int) -> Transform3D:
	# Calculates the scaled and rotated version of a BOX(1,1,1)
	# returned transform is already multiplied by PHYSIC_SPACE_SIZE_FACTOR
	var atom_radius: float = _atomic_nmb_to_radius[in_atomic_nmb]
	var direction_from_atom_to_anchor: Vector3 = in_atom_position.direction_to(in_anchor_position)
	var begin: Vector3 = in_atom_position * PHYSIC_SPACE_SIZE_FACTOR + direction_from_atom_to_anchor * atom_radius
	var anchor_shift: float = NanoVirtualAnchor.MODEL_SIZE * 0.5 * PHYSIC_SPACE_SIZE_FACTOR
	var end: Vector3 = in_anchor_position * PHYSIC_SPACE_SIZE_FACTOR - direction_from_atom_to_anchor * anchor_shift
	var position: Vector3 = (begin + end) / 2.0
	var length: float = begin.distance_to(end)
	var thickness: float = SpringRenderer.MODEL_THICKNESS * 0.5 * PHYSIC_SPACE_SIZE_FACTOR
	var scale := Vector3(thickness, thickness, length)
	var new_transform := Transform3D(Basis(), position).looking_at(end).scaled_local(scale)
	return new_transform


func ray(in_screen_position: Vector2, in_camera: Camera3D) -> RaycastResult:
	var ray_normal: Vector3 = in_camera.project_ray_normal(in_screen_position)
	var ray_origin: Vector3 = in_camera.project_ray_origin(in_screen_position) * PHYSIC_SPACE_SIZE_FACTOR
	var collision_layer: int = _get_collision_layer()
	var atom_collider: int = _atom_collision_space.raycast(ray_origin, ray_normal, collision_layer)
	var bond_collider: int = _bond_collision_space.raycast(ray_origin, ray_normal, collision_layer)
	var spring_collider: int = _spring_collision_space.raycast(ray_origin, ray_normal, collision_layer)
	var hit_result: RaycastResult = RaycastResult.new(atom_collider, bond_collider, spring_collider,
			_structure_context, ray_origin)
	return hit_result


func ray_atom(in_screen_position: Vector2, in_camera: Camera3D) -> int:
	var ray_normal: Vector3 = in_camera.project_ray_normal(in_screen_position)
	var ray_origin: Vector3 = in_camera.project_ray_origin(in_screen_position) * PHYSIC_SPACE_SIZE_FACTOR
	var atom_id: int = _atom_collision_space.raycast(ray_origin, ray_normal, _get_collision_layer())
	return atom_id


func ray_bond(in_screen_position: Vector2, in_camera: Camera3D) -> int:
	var ray_normal: Vector3 = in_camera.project_ray_normal(in_screen_position)
	var ray_origin: Vector3 = in_camera.project_ray_origin(in_screen_position) * PHYSIC_SPACE_SIZE_FACTOR
	var bond_id: int = _bond_collision_space.raycast(ray_origin, ray_normal, _get_collision_layer())
	return bond_id


func ray_virtual_object(in_screen_position: Vector2, in_camera: Camera3D) -> bool:
	var ray_normal: Vector3 = in_camera.project_ray_normal(in_screen_position)
	var ray_origin: Vector3 = in_camera.project_ray_origin(in_screen_position) * PHYSIC_SPACE_SIZE_FACTOR
	var collided_virtual_object_id: int = _atom_collision_space.raycast(ray_origin, ray_normal, CollisionLayer.VIRTUAL_OBJECT)
	return (collided_virtual_object_id == VIRTUAL_OBJECT_ID)


func get_atoms_colliding_with_screen_rectangle(in_camera: Camera3D, in_screen_rect: Rect2i) -> PackedInt32Array:
	return _atom_collision_space.frustrum_intersection(in_camera, in_screen_rect, _get_collision_layer())


func get_bonds_colliding_with_screen_rectangle(in_camera: Camera3D, in_screen_rect: Rect2i) -> PackedInt32Array:
	return _bond_collision_space.frustrum_intersection(in_camera, in_screen_rect, _get_collision_layer())


func find_springs_colliding_with_screen_rectangle(in_camera: Camera3D, in_screen_rect: Rect2i) -> PackedInt32Array:
	return _spring_collision_space.frustrum_intersection(in_camera, in_screen_rect, _get_collision_layer())


func _get_collision_layer() -> int:
	if _hydrogens_enabled:
		return CollisionLayer.DEFAULT | CollisionLayer.HYDROGEN
	return CollisionLayer.DEFAULT


func get_closest_atom_to_screen_point(in_camera: Camera3D, in_screen_point: Vector2) -> int:
	var result: int = AtomicStructure.INVALID_ATOM_ID
	var nano_structure: NanoStructure = _structure_context.nano_structure
	if  not nano_structure is AtomicStructure or nano_structure.get_valid_atoms_count() == 0:
		return result
	
	var viewport_rect := Rect2i(Vector2i.ZERO, in_camera.get_viewport().size)
	var scan_rect := Rect2i(in_screen_point, Vector2i.ZERO)
	# tries to lower scan step a bit every frame, on avg this won't do more then two queries per
	# frame when camera is static
	var scan_step: int = max(_last_scan_size * 0.99, 10)
	var candidates: PackedInt32Array = PackedInt32Array()
	var final_scan_size: int = 0
	while candidates.is_empty() and scan_rect.size != viewport_rect.size:
		final_scan_size += scan_step
		scan_rect = scan_rect.grow(scan_step).intersection(viewport_rect)
		candidates = _atom_collision_space.frustrum_intersection(in_camera, scan_rect, CollisionSpace.DEFAULT_COLLISION_LAYER, 1000)

	_last_scan_size = final_scan_size
	var current_min_distance_sqr: float = 1000.0 * 1000.0
	for atom_id in candidates:
		var atom_position: Vector3 = nano_structure.atom_get_position(atom_id)
		var distance_sqr: float = in_camera.position.distance_squared_to(atom_position)
		if distance_sqr < current_min_distance_sqr:
			current_min_distance_sqr = distance_sqr
			result = atom_id
	return result


## Workaround for selection preview
func disable_pernamently() -> void:
	_disabled = true
	_clear_physic_space()
	var nano_structure: NanoStructure = _structure_context.nano_structure
	nano_structure.get_representation_settings().representation_changed.disconnect(_on_representation_settings_representation_changed)
	nano_structure.get_representation_settings().hydrogen_visibility_changed.disconnect(_on_representation_settings_hydrogen_visibility_changed)
	nano_structure.visibility_changed.disconnect(_on_nano_structure_visibility_changed)
	nano_structure.atoms_added.disconnect(_on_nano_structure_atoms_added)
	nano_structure.atoms_removed.disconnect(_on_nano_structure_atoms_removed)
	nano_structure.atoms_moved.disconnect(_on_nano_structure_atoms_moved)
	nano_structure.atoms_atomic_number_changed.disconnect(_on_nano_structure_atoms_atomic_number_changed)
	nano_structure.atoms_visibility_changed.disconnect(_on_nano_structure_atoms_visibility_changed)
	nano_structure.atoms_cleared.disconnect(_on_nano_structure_atoms_cleared)
	nano_structure.bonds_created.disconnect(_on_nano_structure_bonds_created)
	nano_structure.bonds_removed.disconnect(_on_nano_structure_bonds_removed)
	nano_structure.bonds_changed.disconnect(_on_nano_structure_bonds_changed)
	nano_structure.bonds_visibility_changed.disconnect(_on_nano_structure_bonds_visibility_changed)
	nano_structure.springs_added.disconnect(_on_nano_structure_springs_added)
	nano_structure.springs_moved.disconnect(_on_nano_structure_springs_moved)
	nano_structure.springs_removed.disconnect(_on_nano_structure_springs_removed)
	if nano_structure is NanoVirtualMotor and nano_structure.transform_changed.is_connected(_on_motor_transform_changed):
		nano_structure.transform_changed.disconnect(_on_motor_transform_changed)
	if nano_structure is NanoVirtualAnchor:
		nano_structure.position_changed.disconnect(_on_anchor_position_changed)


func _clear_physic_space() -> void:
	_atom_collision_space.free_colliders_and_get_shapes()
	for atom_shape_rid: RID in _atomic_nmb_to_collision_shape.values():
		PhysicsServer3D.free_rid(atom_shape_rid)
	
	# bond_shapes_to_remove: Array[RID]
	var bond_shapes_to_remove: Array = _bond_collision_space.free_colliders_and_get_shapes()
	for bond_shape_rid: RID in bond_shapes_to_remove:
		PhysicsServer3D.free_rid(bond_shape_rid)
	
	_spring_collision_space.free_colliders_and_get_shapes()
	
	_atomic_nmb_to_collision_shape.clear()
	_atomic_nmb_to_radius.clear()
	_bond_order_and_atom_radius_to_bond_radius.clear()
	_motor_shape_rid = RID()
	_anchor_shape_rid = RID()
	_spring_shape_rid = RID()


func remove_atom(in_atom_id: int) -> void:
	_atom_collision_space.free_collider_and_get_related_shape(in_atom_id)




func create_state_snapshot() -> Dictionary:
	# for now collision engine should be build in from scratch, just ensure it's being cleared
	return {}
	#TODO, profile and check if it's better to snapshot state somehow
	#var snapshot: Dictionary = {
		#"_disabled" = _disabled,
		#"_last_scan_size" = _last_scan_size,
		#"_need_to_recreate_on_tree_enter" = _need_to_recreate_on_tree_enter,
		#"_atomic_nmb_to_collision_shape" = _atomic_nmb_to_collision_shape.duplicate(true), #IS IT?
		#"_atomic_nmb_to_radius" = _atomic_nmb_to_radius.duplicate(),
		#"_bond_order_and_atom_radius_to_bond_radius" = _bond_order_and_atom_radius_to_bond_radius.duplicate(),
		#"_motor_shape_rid" = _motor_shape_rid,
		#"_anchor_shape_rid" = _anchor_shape_rid,
		#"_spring_shape_rid" = _spring_shape_rid,
		#"_hydrogens_enabled" = _hydrogens_enabled,
		#"_atom_collision_space" = _atom_collision_space._create_snapshot(),
		#"_bond_collision_space" = _bond_collision_space._create_snapshot(),
		#"_spring_collision_space" = _spring_collision_space._create_snapshot(),
	#}
	#return snapshot


func rebuild(in_structure_context: StructureContext) -> void:
	_clear_physic_space()
	initialize(in_structure_context)


class RaycastResult:
	enum HitType {
		HIT_NOTHING,
		HIT_ATOM,
		HIT_BOND,
		HIT_SPRING,
		HIT_SHAPE
	}
	
	var atom_id: int = AtomicStructure.INVALID_ATOM_ID
	var bond_id: int = AtomicStructure.INVALID_BOND_ID
	var spring_id: int = AtomicStructure.INVALID_SPRING_ID
	var hit_type: HitType = HitType.HIT_NOTHING
	
	
	func _init(in_atom_id: int, in_bond_id: int, in_spring_id: int, in_structure_context: StructureContext,
				in_query_source: Vector3) -> void:
		var nano_structure: NanoStructure = in_structure_context.nano_structure
		atom_id = in_atom_id
		bond_id = in_bond_id
		spring_id = in_spring_id
	
		var is_atom_colliding: bool = atom_id != AtomicStructure.INVALID_ATOM_ID
		var is_bond_colliding: bool = bond_id != AtomicStructure.INVALID_BOND_ID
		var is_spring_colliding: bool = spring_id != AtomicStructure.INVALID_SPRING_ID
		var multiple_collisions: bool = is_atom_colliding and is_bond_colliding or \
				is_spring_colliding and is_atom_colliding or is_spring_colliding and is_bond_colliding
		if multiple_collisions:
			var atom_position: Vector3 = nano_structure.atom_get_position(atom_id) if is_atom_colliding else Vector3.INF
			var bond_data: Vector3i = nano_structure.get_bond(bond_id) if bond_id > 0 else Vector3i()
			var bond_position: Vector3 = (nano_structure.atom_get_position(bond_data.x) +
					nano_structure.atom_get_position(bond_data.y)) / 2.0 if is_bond_colliding else Vector3.INF
			var spring_position: Vector3 = Vector3.INF
			if is_spring_colliding:
				spring_position = (nano_structure.spring_get_atom_position(spring_id) + \
						nano_structure.spring_get_anchor_position(spring_id, in_structure_context)) / 2.0
			var atom_dst_to_ray_source: float = in_query_source.distance_squared_to(atom_position)
			var bond_dst_to_ray_source: float = in_query_source.distance_squared_to(bond_position)
			var spring_dst_to_ray_source: float = in_query_source.distance_squared_to(spring_position)
			var atom_closest: bool = atom_dst_to_ray_source <= bond_dst_to_ray_source and atom_dst_to_ray_source <= spring_dst_to_ray_source
			var bond_closest: bool = bond_dst_to_ray_source <= atom_dst_to_ray_source and bond_dst_to_ray_source <= spring_dst_to_ray_source
			var spring_closest: bool = spring_dst_to_ray_source <= atom_dst_to_ray_source and spring_dst_to_ray_source <= bond_dst_to_ray_source
			if atom_closest:
				hit_type = HitType.HIT_ATOM
			elif bond_closest:
				hit_type = HitType.HIT_BOND
			elif spring_closest:
				hit_type = HitType.HIT_SPRING
			else:
				assert(false, "cannot determine hit_type")
				pass
		
		elif is_atom_colliding:
			hit_type = HitType.HIT_ATOM
		
		elif is_bond_colliding:
			hit_type = HitType.HIT_BOND
		
		elif is_spring_colliding:
			hit_type = HitType.HIT_SPRING

